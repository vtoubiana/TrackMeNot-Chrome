<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>trackmenot.js - TrackMeNot JS Docs</title>
    
    
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://trackmenot.io" target="_blank" class="menu-item" id="TMN Official Site" >Project Website</a></h2><h3>Modules</h3><ul><li><a href="TRACKMENOT.module_TMNSearch.html">TMNSearch</a><ul class='methods'><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~trim">trim</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~cerr">cerr</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~roll">roll</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~randomElt">randomElt</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~getElementsByAttrValue">getElementsByAttrValue</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~getEngineById">getEngineById</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~getYahooId">getYahooId</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~chooseElt">chooseElt</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~getTMNTab">getTMNTab</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~deleteTab">deleteTab</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~createTab">createTab</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~iniTab">iniTab</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~monitorBurst">monitorBurst</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~checkForSearchUrl">checkForSearchUrl</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~isBursting">isBursting</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~randomQuery">randomQuery</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~validateFeeds">validateFeeds</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~extractQueries">extractQueries</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~isBlackList">isBlackList</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~queryOk">queryOk</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~addQuery">addQuery</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~filterKeyWords">filterKeyWords</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~addRssTitles">addRssTitles</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~readDHSList">readDHSList</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~doRssFetch">doRssFetch</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~getSubQuery">getSubQuery</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~getQuery">getQuery</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~updateOnErr">updateOnErr</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~updateOnSend">updateOnSend</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~createLog">createLog</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~doSearch">doSearch</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~sendQuery">sendQuery</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~queryToURL">queryToURL</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~rescheduleOnError">rescheduleOnError</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~reschedule">reschedule</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~scheduleNextSearch">scheduleNextSearch</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~enterBurst">enterBurst</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~saveOptions">saveOptions</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~stopTMN">stopTMN</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~formatNum">formatNum</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~add_log">add_log</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~sendClickEvent">sendClickEvent</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~startTMN">startTMN</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~handleRequest">handleRequest</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~setDefaultOptions">setDefaultOptions</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~initQueries">initQueries</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~onError">onError</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~getStorage">getStorage</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~setDefaultEngines">setDefaultEngines</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~restoreOptions">restoreOptions</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~updateOptions">updateOptions</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~setEngines">setEngines</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~restoreQueries">restoreQueries</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~_logStorageChange">_logStorageChange</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~_restoreTMN">_restoreTMN</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~_getEngine">_getEngine</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~_getQueries">_getQueries</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~_getStorage">_getStorage</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~_resetSettings">_resetSettings</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNSearch.html#~_preserveTMNTab">_preserveTMNTab</a></li></ul></li><li><a href="TRACKMENOT.module_TMNInjected.html">TMNInjected</a><ul class='methods'><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~testAd_google">testAd_google</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~testAd_yahoo">testAd_yahoo</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~testAd_aol">testAd_aol</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~testAd_bing">testAd_bing</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~testAd_baidu">testAd_baidu</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~getButton_google">getButton_google</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~getButton_yahoo">getButton_yahoo</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~getButton_bing">getButton_bing</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~getButton_aol">getButton_aol</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~getButton_baidu">getButton_baidu</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~SearchBox_google">SearchBox_google</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~SearchBox_yahoo">SearchBox_yahoo</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~SearchBox_bing">SearchBox_bing</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~SearchBox_aol">SearchBox_aol</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~SearchBox_baidu">SearchBox_baidu</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~testad">testad</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~get_box">get_box</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~get_button">get_button</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~roll">roll</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~cout">cout</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~stripTags">stripTags</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~pressEnter">pressEnter</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~downKey">downKey</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~pressKey">pressKey</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~inputChar">inputChar</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~releaseKey">releaseKey</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~simulateClick">simulateClick</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~clickButton">clickButton</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~clickElt">clickElt</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~getElementsByAttrValue">getElementsByAttrValue</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~getCommonWords">getCommonWords</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~getTimingArray">getTimingArray</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~typeQuery">typeQuery</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~queryToURL">queryToURL</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~sendQuery">sendQuery</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~isSafeHost">isSafeHost</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~sendPageLoaded">sendPageLoaded</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~add_log">add_log</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~updateStatus">updateStatus</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~getTMNCurrentURL">getTMNCurrentURL</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~setTMNCurrentURL">setTMNCurrentURL</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~handleRequest">handleRequest</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~checkIsActiveTab">checkIsActiveTab</a></li><li data-type='method'><a href="TRACKMENOT.module_TMNInjected.html#~hasLoaded">hasLoaded</a></li></ul></li><li><a href="TRACKMENOT.module_Menus.html">Menus</a><ul class='methods'><li data-type='method'><a href="TRACKMENOT.module_Menus.html#~showHelp">showHelp</a></li><li data-type='method'><a href="TRACKMENOT.module_Menus.html#~toggleOnOff">toggleOnOff</a></li><li data-type='method'><a href="TRACKMENOT.module_Menus.html#~toggleTabFrame">toggleTabFrame</a></li><li data-type='method'><a href="TRACKMENOT.module_Menus.html#~onLoadMenu">onLoadMenu</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="Options.html">Options</a><ul class='methods'><li data-type='method'><a href="Options.html#.loadHandlers">loadHandlers</a></li><li data-type='method'><a href="Options.html#.getEngIndexById">getEngIndexById</a></li><li data-type='method'><a href="Options.html#.updateEngineList">updateEngineList</a></li><li data-type='method'><a href="Options.html#.clearOptions">clearOptions</a></li><li data-type='method'><a href="Options.html#.addEngine">addEngine</a></li><li data-type='method'><a href="Options.html#.delEngine">delEngine</a></li><li data-type='method'><a href="Options.html#.TMNSetOptionsMenu">TMNSetOptionsMenu</a></li><li data-type='method'><a href="Options.html#.setFrequencyMenu">setFrequencyMenu</a></li><li data-type='method'><a href="Options.html#.TMNShowLog">TMNShowLog</a></li><li data-type='method'><a href="Options.html#.TMNShowEngines">TMNShowEngines</a></li><li data-type='method'><a href="Options.html#.TMNShowQueries">TMNShowQueries</a></li><li data-type='method'><a href="Options.html#.saveOptions">saveOptions</a></li><li data-type='method'><a href="Options.html#.handleRequest">handleRequest</a></li><li data-type='method'><a href="Options.html#.onError">onError</a></li><li data-type='method'><a href="Options.html#.getStorage">getStorage</a></li><li data-type='method'><a href="Options.html#.TMNLoadOptionWindow">TMNLoadOptionWindow</a></li></ul></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">trackmenot.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*******************************************************************************
    This file is part of TrackMeNot).

    TrackMeNot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation,  version 2 of the License.

    TrackMeNot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar.  If not, see &lt;http://www.gnu.org/licenses/>.
 ********************************************************************************/
"use strict";

var api;
if (chrome == undefined) {
    api = browser;
} else {
    api = chrome;
}

var _ = api.i18n.getMessage;

if (!TRACKMENOT) var TRACKMENOT = {};

/** The TRACKMENOT.TMNSearch object, used as a high-level interface and manager 
 * for the core search functionality of the extension. Created in trackmenot.js.
 * @exports TRACKMENOT.TMNSearch 
 * @property {number} tmn_tab_id - the ID of the tab controlled by TMN for searches
 * @property {Boolean} debug_ - flag for whether to log to console debug messages
 * @property {Boolean} useIncrementals - constant setting for random possibility to search about the same topic / dummy query multiple times ("incremenetal" searches)
 * @property {array} incQueries - variable used to set an incremental sequence of searches about the same topic / dummy query
 * @property {string} engine - the current search engine to search on
 * @property {object} tmn_engines - an object containing each engine known to TMN, whether it is enabled for searches, and associated metadata (e.g. the engine's base search URL)
 * @property {object} TMNQueries - the dummy query strings for TMN to search with, organized by keys representing the method of query generation {@link typeoffeeds} ("rss", "extracted", "dhs")
 * @property {array} zeit_queries - a preset array of query terms representative of a "zeitgeist"
 * @property {array} tmnLogs - running log of all dummy queries searched, used to update local storage for display of search logs in options page
 * @property {array} typeoffeeds - array of keynames for the dummy query generation methods in use
 * @property {string} prev_engine - the last engine used to send a search
 * @property {string} burstEngine - the consistent search engine name for a sequence of "bursted" searches
 * @property {number} burstTimeout - value in milliseconds to wait between searches in a "burst"
 * @property {number} burstCount - the number of searches sent within a sequence of "bursted" searches
 * 
 * @property {object} tmn_options - contains the user-configured options of TMN extension, restored from local storage between sessions
 * 
 * @property {object} currentUrlMap - map/dictionary of locally saved URL structures for non-default search engines
 * @property tmn_searchTimer - the setTimeout timer for scheduling the next search
 * @property {string} tmn_mode - the current search function mode - from the set {"timed", "recovery" (retrying when a search fails), or "burst"}
 * @property tmn_errTimeout -  a setTimeout timer 3*the search timeout to reinitiate search in case of errors
 * @property {Boolean} tmn_scheduledSearch - status indicator for whether the next search has been scheduled
 * @property {Boolean} tmn_hasloaded - status indicator for whether or not the search results page from the current search has loaded
 * @property {string} currentTMNURL - the current search URL
 * @property {number} tmn_logged_id - id of the last logged search
 * */
TRACKMENOT.TMNSearch = function() {
    var tmn_tab_id = -1;

    var debug_ = true;
    var useIncrementals = true;
    var incQueries = [];
    var engine = 'google';
    var tmn_engines= {};
    var TMNQueries = {};
    var zeit_queries = ["facebook", "youtube", "myspace", "craigslist", "ebay", "yahoo", "walmart", "netflix", "amazon", "home depot", "best buy", "Kentucky Derby", "NCIS", "Offshore Drilling", "Halle Berry", "iPad Cases", "Dorothy Provine", "Emeril", "Conan O'Brien", "Blackberry", "Free Comic Book Day", " American Idol", "Palm", "Montreal Canadiens", "George Clooney", "Crib Recall", "Auto Financing", "Katie Holmes", "Madea's Big Happy Family", "Old Navy Coupon", "Sandra Bullock", "Dancing With the Stars", "M.I.A.", "Matt Damon", "Santa Clara County", "Joey Lawrence", "Southwest Airlines", "Malcolm X", "Milwaukee Bucks", "Goldman Sachs", "Hugh Hefner", "Tito Ortiz", "David McLaughlin", "Box Jellyfish", "Amtrak", "Molly Ringwald", "Einstein Horse", "Oil Spill", " Bret Michaels", "Mississippi Tornado", "Stephen Hawking", "Kelley Blue Book", "Hertz", "Mariah Carey", "Taiwan Earthquake", "Justin Bieber", "Public Bike Rental", "BlackBerry Pearl", "NFL Draft", "Jillian Michaels", "Face Transplant", "Dell", "Jack in the Box", "Rebbie Jackson", "Xbox", "Pampers", "William Shatner", "Earth Day", "American Idol", "Heather Locklear", "McAfee Anti-Virus", "PETA", "Rihanna", "South Park", "Tiger Woods", "Kate Gosselin", "Unemployment", "Dukan Diet", "Oil Rig Explosion", "Crystal Bowersox", "New 100 Dollar Bill", "Beastie Boys", "Melanie Griffith", "Borders", "Tara Reid", "7-Eleven", "Dorothy Height", "Volcanic Ash", "Space Shuttle Discovery", "Gang Starr", "Star Trek", "Michael Douglas", "NASCAR", "Isla Fisher", "Beef Recall", "Rolling Stone Magazine", "ACM Awards", "NASA Space Shuttle", "Boston Marathon", "Iraq", "Jennifer Aniston"];
    var tmnLogs = [];
    var typeoffeeds = ['zeitgeist'];
    var prev_engine = null;  
    var burstEngine = '';
    var burstTimeout = 6000;
    var burstCount = 0;
    
    var tmn_options = {};
    
    var currentUrlMap;
    var tmn_searchTimer = null;
    var tmn_logged_id = 0;
    var tmn_mode = 'timed';
    var tmn_errTimeout = null;
    var tmn_scheduledSearch = false;
    var tmn_hasloaded = false;
    var currentTMNURL = '';


    var skipex = new Array(
        /calendar/i, /advanced/i, /click /i, /terms/i, /Groups/i,
        /Images/, /Maps/, /search/i, /cache/i, /similar/i, /&amp;#169;/,
        /sign in/i, /help[^Ss]/i, /download/i, /print/i, /Books/i, /rss/i,
        /google/i, /bing/i, /yahoo/i, /aol/i, /html/i, /ask/i, /xRank/,
        /permalink/i, /aggregator/i, /trackback/, /comment/i, /More/,
        /business solutions/i, /result/i, / view /i, /Legal/, /See all/,
        /links/i, /submit/i, /Sites/i, / click/i, /Blogs/, /See your mess/,
        /feedback/i, /sponsored/i, /preferences/i, /privacy/i, /News/,
        /Finance/, /Reader/, /Documents/, /windows live/i, /tell us/i,
        /shopping/i, /Photos/, /Video/, /Scholar/, /AOL/, /advertis/i,
        /Webmasters/, /MapQuest/, /Movies/, /Music/, /Yellow Pages/,
        /jobs/i, /answers/i, /options/i, /customize/i, /settings/i,
        /Developers/, /cashback/, /Health/, /Products/, /QnABeta/,
        /&lt;more>/, /Travel/, /Personals/, /Local/, /Trademarks/,
        /cache/i, /similar/i, /login/i, /mail/i, /feed/i
    );
    
    /** Utility function that replaces each newline character in string s with a space character " ".
     * Used to clean generated dummy queries.
     * @function trim
     * @inner
     * @param {string} s - the string to trim
     * */
     function trim(s) {
        return s.replace(/\n/g, '');
    }
    /** Logs an error message in the console, marking it as from trackmenot.js.
     * @function cerr
     * @inner
     * @param {string} msg - the error message
     * @param {Exception} e - the exception object holding error information
     * */
    function cerr(msg, e) {
        var txt = "[ERROR] " + msg;
        if (e) {
            txt += "\n" + e;
            if (e.message) txt += " | " + e.message;
        } else txt += " / No Exception";
        cout(txt);
    }

    function cout(msg) {
	    console.log(msg);
    }
    function debug(msg) {
        if (debug_)
            console.log("DEBUG: " + msg);
    }
    /** Utility function that generates a random number between min and max, inclusive.
     * @function roll
     * @inner
     * @param {Number} min - the minimum
     * @param {Number} max - the maximum
     * */
    function roll(min, max) {
        return Math.floor(Math.random() * (max + 1)) + min;
    }
    /** Utility function that selects a random element of the input array.
     * @function randomElt
     * @inner
     * @param {Array} array - the array from which to select a random element
     * */
    function randomElt(array) {
        debug("Array length: " + array.length);
        var index = roll(0, array.length - 1);
        return array[index];
    }


// Engine functions
    /** Used (and redundantly defined) in tmn_search.js to get search button and boxes, by checking each element
     * of a particular type (e.g. "input") with a particular attribute name (e.g. "name"),
     * with a search engine specific value indicating implicitly it serves a designated 
     * search engine role in the interface. Not used in trackmenot.js
     * @function getElementsByAttrValue
     * @inner
     * @param dom - the document object model of a webpage
     * @param {string} nodeType - the tag name of the type of node (e.g. "input")
     * @param {string} attrName - the attribute name associated with a particular role-identifying value
     * @param {string} nodeValue - the target value of the attribute
     * */
    function getElementsByAttrValue(dom, nodeType, attrName, nodeValue) {
        var outlines = dom.getElementsByTagName(nodeType);
        for (var i = 0; i &lt; outlines.length; i++) {
            if (outlines[i].hasAttribute(attrName) &amp;&amp; outlines[i].getAttribute(attrName) === nodeValue)
                return outlines[i];
        }
        return null;
    }





    var default_engines = {"list":[
        {
			id: 'google',
			name: 'Google Search',
			urlmap: "https://www.google.com/search?hl=en&amp;q=|",
			enabled: true,
			regexmap: "^(https?:\/\/[a-z]+\.google\.(co\\.|com\\.)?[a-z]{2,3}\/(search){1}[\?]?.*?[&amp;\?]{1}q=)([^&amp;]*)(.*)$"
		},
        {
            id: 'yahoo',
            name: 'Yahoo! Search',
            urlmap: "http://search.yahoo.com/search;_ylt=" + getYahooId() + "?ei=UTF-8&amp;fr=sfp&amp;fr2=sfp&amp;p=|&amp;fspl=1",
            enabled: true,
            regexmap: "^(https?:\/\/[a-z.]*?search\.yahoo\.com\/search.*?p=)([^&amp;]*)(.*)$",
            host: "([a-z.]*?search\.yahoo\.com)$"
        },
        {
            id: 'bing',
            name: 'Bing Search',
            urlmap: "http://www.bing.com/search?q=|",
            enabled: true,
            regexmap: "^(https?:\/\/www\.bing\.com\/search\?[^&amp;]*q=)([^&amp;]*)(.*)$",
            host: "(www\.bing\.com)$"
        },
        {
            id: 'baidu',
            name: 'Baidu Search',
            urlmap: "http://www.baidu.com/s?wd=|",
            enabled: false,
            regexmap: "^(https?:\/\/www\.baidu\.com\/s\?.*?wd=)([^&amp;]*)(.*)$",
            host: "(www\.baidu\.com)$"
        },
        {
            id: 'aol',
            name: 'Aol Search',
            urlmap: "http://search.aol.com/aol/search?q=|",
            enabled: false,
            regexmap: "^(https?:\/\/[a-z0-9.]*?search\.aol\.com\/aol\/search\?.*?q=)([^&amp;]*)(.*)$",
            host: "([a-z0-9.]*?search\.aol\.com)$"
        }
    ]}

    /** 
     * Finds an engine in tmn_engines with a given id
     * @function getEngineById
     * @inner
     * @param {string} id - the engine id
     * */
    function getEngineById(id) {
        return tmn_engines.list.filter(function(a) {
            return a.id === id;
        })[0];
    }

    /** 
     * Generates an ID to insert into the Yahoo search URL
     * @function getYahooId
     * @inner
     * */
    function getYahooId() {
        var id = "A0geu";
        while (id.length &lt; 24) {
            var lower = Math.random() &lt; .5;
            var num = parseInt(Math.random() * 38);
            if (num === 37) {
                id += '_';
                continue;
            }
            if (num === 36) {
                id += '.';
                continue;
            }
            if (num &lt; 10) {
                id += String.fromCharCode(num + 48);
                continue;
            }
            num += lower ? 87 : 55;
            id += String.fromCharCode(num);
        }
        //cout("GENERATED ID="+id);
        return id;
    }
    /** 
     * Duplicate function to randomElt, chooses a random element of input array, used once
     * in scheduleNextSearch
     * @function chooseElt
     * @inner
     * @param {Array} arr - the input array
     * */
    function chooseElt(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    }




// Tab functions
    /** using the new value for the useT option, determine if there was a change and if so, either create or delete a tab (corresponding to that new value) 
     * @function changeTabStatus
     * @inner
     * @private
     * @param {Boolean} useT - whether or not TMN is set to use a tab for its searches 
     * */
    function changeTabStatus(useT) {
        if (useT === tmn_options.useTab) return;
        tmn_options.useTab= useT;
        if (useT) {
            createTab();
        } else {
            deleteTab();
        }
    }
    /** returns tmn_tab_id, the id for the tab 
     * @function getTMNTab
     * @inner
     * @returns {Number} tmn_tab_id
     * */
    function getTMNTab() {
        debug("Trying to access to the tab: " + tmn_tab_id);
        return tmn_tab_id;
    }
    /** Delete the TMN search tab using api.tabs.remove
     * @function deleteTab
     * @inner
     * */
    function deleteTab() {
        if (tmn_tab_id === -1) return;
        api.tabs.remove(tmn_tab_id);
        tmn_tab_id = -1;
    }
    /** Attempts to create a TMN search tab.
     * @function createTab
     * @inner
     * @param {Object} [pendingRequest] - the pending search, if no tab exists but useTab is enabled
     * */
    function createTab( pendingRequest) {
        if (!tmn_options.useTab || tmn_tab_id !== -1) return;
        if (debug) cout('Creating tab for TrackMeNot');
        try {
            api.tabs.create({
                'active': false,
                'url': 'http://www.google.com'
            }, function (e) {iniTab(e,pendingRequest)});
        } catch (ex) {
            cerr('Can no create TMN tab:', ex);
        }
    }
    /** After creating a new tab, send the first search.
     * @function iniTab
     * @inner
     * @param {Object} tab - the tab object returned after creating a tab
     * @param {Object} pendingRequest - the TMN request object containing the pending search's info
     * */
    function iniTab(tab,pendingRequest) {
        tmn_tab_id = tab.id;

        
        if (pendingRequest!== null) {
            console.log(JSON.stringify(pendingRequest));
            api.tabs.sendMessage(tmn_tab_id, pendingRequest);
            cout('Message sent to the tab: ' + tmn_tab_id + ' : ' + pendingRequest);
        }
    }


    /** Create a webNavigation listener to monitor user browsing behavior, 
     * and if the user searches on an enabled engine, fire a burst of obfuscation searches.
     * @function monitorBurst
     * @inner
     * */
    function monitorBurst() {
        api.webNavigation.onCommitted.addListener(function(e) {
            var url = e.url;
            var tab_id = e.tabId;
            var result = checkForSearchUrl(url);
            if (!result) {
                if (tab_id === tmn_tab_id) {
                    debug("TMN tab tryign to visit: " + url);
                }
                return;
            }

            //
            // -- EXTRACT DATA FROM THE URL
            var pre = result[1];
            var query = result[2];
            var post = result[3];
            var eng = result[4];
            var asearch = pre + '|' + post;
            if (tmn_tab_id === -1 || tab_id !== tmn_tab_id) {
                debug("Worker find a match for url: " + url + " on engine " + eng + "!");
                if (tmn_options.burstMode) enterBurst(eng);
                var engine = getEngineById(eng);
                if (engine &amp;&amp; engine.urlmap !== asearch) {
                    engine.urlmap = asearch;
                    api.storage.local.set({'engines':tmn_engines});
                    var logEntry = createLog('URLmap', eng, null, null, null, asearch)
                    log(logEntry);
                    debug("Updated url fr search engine " + eng + ", new url is " + asearch);
                }
            }
        });

    }

    /** 
     * Used as a callback function for every new page of user's browsing behavior
     * to check if the user did a search on a TMN-enabled search engine.
     * @function checkForSearchUrl
     * @inner
     * @param {string} url - the input url to check
     * @returns {Array} either null if no match, or the length-4 array containing the .match(engine_regex)
     * */
    function checkForSearchUrl(url) {
        var result = null;
	    var eng;
        for (var i = 0; i &lt; tmn_engines.list.length; i++) {
            eng = tmn_engines.list[i];
            var regex = eng.regexmap;
            debug("  regex: " + regex + "  ->\n                   " + url);
            result = url.match(regex);
            if (result) {
                cout(regex + " MATCHED! on " + eng.id);
                break;
            }
        }
        if (!result) return null;

        if (result.length !== 4) {
            if (result.length === 6 &amp;&amp; eng.id === "google") {
                result.splice(2, 2);
                result.push(eng.id);
                return result;
            }
            cerr("REGEX_ERROR: " + url);
        }
        result.push(eng.id);
        return result;
    }

    /** 
     * Checks if TMN is in burst mode and has begun a burst of searches
     * @function isBursting
     * @inner
     * @returns {Boolean} whether or not TMN is midway thru an active burst
     * */
    function isBursting() {
        return (tmn_options.burstMode &amp;&amp; (burstCount > 0));
    }

    /** 
     * Returns a query randomly by selecting a random query generation method
     * and then choosing a random query from the selected generation method's dummy query list.
     * @function randomQuery
     * @inner
     * @returns {string} the dummy query term
     * */
    function randomQuery() {
        var qtype = randomElt(typeoffeeds);
        var queries = [];
        if (qtype !== 'zeitgeist' &amp;&amp; qtype !== 'extracted') {
            var queryset = TMNQueries[qtype];
            queries = randomElt(queryset).words;
        } else queries = TMNQueries[qtype];
        var term = trim(randomElt(queries));
        if (!term || term.length &lt; 1)
            throw new Error(" getQuery.term='" + term + "'");
        return term;
    }
    /** 
     * When a user saves a new set of RSS feeds in the options page, 
     * fetch those RSS feeds and save options.
     * @function validateFeeds
     * @inner
     * @param {Array} the list of RSS feeds
     * */
    function validateFeeds(param) {
        TMNQueries.rss = [];
        tmn_options.feedList = param.feeds;
        var feeds = tmn_options.feedList;
        for (var i = 0; i &lt; feeds.length; i++)
            doRssFetch(feeds[i]);
        saveOptions();
    }
    /** 
     * Deprecated function to extract keyphrases from search results 
     * and add them to "extracted" dummy query list.
     * @function extractQueries
     * @inner
     * @param {string} html - HTML body of search results
     * @deprecated unused anywhere in the code
     * */
    function extractQueries(html) {
        var forbiddenChar = new RegExp("^[ @#&lt;>\"\\\/,;'�{}:?%|\^~`=]", "g");
        var splitRegExp = new RegExp('^[\\[\\]\\(\\)\\"\']', "g");

        if (!html) {
            cout("NO HTML!");
            return;
        }

        var phrases = new Array();

        // Parse the HTML into phrases
        var l = html.split(/((&lt;\?tr>)|(&lt;br>)|(&lt;\/?p>))/i);
        for (var i = 0; i &lt; l.length; i++) {
            if (!l[i] || l[i] == "undefined") continue;
            l[i] = l[i].replace(/(&lt;([^>]+)>)/ig, " ");
            //if (/([a-z]+ [a-z]+)/i.test(l[i])) {
            //var reg = /([a-z]{4,} [a-z]{4,} [a-z]{4,} ([a-z]{4,} ?) {0,3})/i;
            var matches = l[i].split(" "); //reg.exec(l[i]);
            if (!matches || matches.length &lt; 2) continue;
            var newQuery = trim(matches[1]);
            // if ( phrases.length >0 ) newQuery.unshift(" ");
            if (newQuery &amp;&amp; phrases.indexOf(newQuery) &lt; 0)
                phrases.push(newQuery);
        }
        var queryToAdd = phrases.join(" ");
        TMNQueries.extracted = [].concat(TMNQueries.extracted);
        while (TMNQueries.extracted.length > 200) {
            var rand = roll(0, TMNQueries.extracted.length - 1);
            TMNQueries.extracted.splice(rand, 1);
        }
        cout(TMNQueries.extracted)
        addQuery(queryToAdd, TMNQueries.extracted);
    }
    /** If the blacklist is enabled, check if a dummy query is in the blacklist.
     * @function isBlackList
     * @inner
     * @param {string} term - the query to check
     * @returns {Boolean} whether the term is in the blacklist (false if blacklist disabled)
     * */
    function isBlackList(term) {
        if (!tmn_options.use_black_list) return false;
        var words = term.split(/\W/g);
        for (var i = 0; i &lt; words.length; i++) {
            if (tmn_options.kwBlackList.indexOf(words[i].toLowerCase()) >= 0)
                return true;
        }
        return false;
    }
    /** Checks if a query term comes from a set of typical search navigation/bot-like terms (e.g. "Maps", "More")
     * @function queryOk
     * @inner
     * @param {string} a- the query to check
     * @returns {Boolean} if the query does not match any of the search nav/bot-like terms
     * */
    function queryOk(a) {
        for (let i = 0; i &lt; skipex.length; i++) {
            if (skipex[i].test(a))
                return false;
        }
        return true;
    }
    /** Checks a search query term's validity and if it passes, adds it to the input queryList
     * @function addQuery
     * @inner
     * @param {string} term - the query to add
     * @param {array} queryList - the list of queries
     * @returns {Boolean} if the query passed checks and was added successfully 
     * */
    function addQuery(term, queryList) {
        var noniso = new RegExp("[^a-zA-Z0-9_.\ \\u00C0-\\u00FF+]+", "g");

        term = term.replace(noniso, '');
        term = trim(term);

        if (isBlackList(term))
            return false;

        if (!term || (term.length &lt; 3) || (queryList.indexOf(term) > 0))
            return false;

        if (term.indexOf("\"\"") > -1 || term.indexOf("--") > -1)
            return false;

        // test for negation of a single term (eg '-prison')
        if (term.indexOf("-") === 0 &amp;&amp; term.indexOf(" ") &lt; 0)
            return false;

        if (!queryOk(term))
            return false;

        queryList.push(term);
        //gtmn.cout("adding("+gtmn._queries.length+"): "+term);

        return true;
    }
    /** Takes a title from an RSS feed and removes unwanted characters
     * @function filterKeyWords
     * @inner
     * @param {string} rssTitles - an rss title pulled from an rss feed
     * @returns {string} addStr - the cleaned rss title string
     * */
    // returns # of keywords added
    function filterKeyWords(rssTitles) {
        var addStr = ""; //tmp-debugging
        var forbiddenChar = new RegExp("[ @#&lt;>\"\\\/,;'�{}:?%|\^~`=]+", "g");
        var splitRegExp = new RegExp('[\\[\\]\\(\\)\\"\']+', "g");
        var wordArray = rssTitles.split(forbiddenChar);

        for (var i = 0; i &lt; wordArray.length; i++) {
            if (!wordArray[i].match('-----')) {
                var word = wordArray[i].split(splitRegExp)[0];
                if (word &amp;&amp; word.length > 2) {
                    W: while (i &lt; (wordArray.length) &amp;&amp; wordArray[i + 1] &amp;&amp; !(wordArray[i + 1].match('-----') ||
                            wordArray[i + 1].match(splitRegExp))) {
                        var nextWord = wordArray[i + 1]; // added new check here -dch
                        if (nextWord !== nextWord.toLowerCase()) {
                            nextWord = trim(nextWord.toLowerCase().replace(/\s/g, '').replace(/[(&lt;>"'�&amp;]/g, ''));
                            if (nextWord.length > 1) {
                                word += ' ' + nextWord;
                            }
                        }
                        i++;
                    }
                    addStr += word.replace(/-----/g, '');
                }
            }
        }
        return addStr;
    }
    /** Checks the result of fetched RSS feed xmlData, and if valid iterates through 
     * and adds each RSS feed title to the RSS feed query list.
     * @function addRssTitles
     * @inner
     * @param xmlData - the xmlData from an RSS feed fetch
     * @param {string} feedUrl - the RSS feed URL
     * @returns {number} 0 if unsuccessful, 1 if successful
     * */
    // returns # of keywords added
    function addRssTitles(xmlData, feedUrl) {
        var rssTitles = "";

        if (!xmlData) return 0; // only for asynchs? -dch

        var feedTitles = xmlData.getElementsByTagName("title");
        if (!feedTitles || feedTitles.length &lt; 2) {
            cerr("no items(" + feedTitles + ") for rss-feed: " + feedUrl);
            return 0;
        }
        var feedObject = {};
        feedObject.name = feedTitles[0].firstChild.nodeValue;
        feedObject.words = [];
        cout('ADD RSS title : ' + feedTitles[0].firstChild.nodeValue);
        for (var i = 1; i &lt; feedTitles.length; i++) {
            if (feedTitles[i].firstChild) {
                rssTitles = feedTitles[i].firstChild.nodeValue;
                rssTitles += " ----- ";
            }
            var queryToAdd = filterKeyWords(rssTitles);
            addQuery(queryToAdd, feedObject.words);
        }
        cout(feedObject.name + " : " + feedObject.words);
        TMNQueries.rss.push(feedObject);

        return 1;
    }
    /** Loads the DHS keywords and fills them into the DHS keyword query list.
     * @function readDHSList
     * @inner
     * */
    function readDHSList() {
        TMNQueries.dhs = [];
        var i = 0;
        var req = Request({
            url: data.url("dhs_keywords.json"),
            overrideMimeType: "application/json",
            onComplete: function(response) {
                if (response.status === 200) {
                    var keywords = response.json.keywords;
                    for (var cat of keywords) {
                        TMNQueries.dhs[i] = {};
                        TMNQueries.dhs[i].category_name = cat.category_name;
                        TMNQueries.dhs[i].words = [];
                        for (var word of cat.category_words)
                            TMNQueries.dhs[i].words.push(word.name);
                        i++;
                    }
                    return;
                } else {
                    var logEntry = createLog('error', "Can not load DHS list");
                    log(logEntry);
                }
            }
        });
        req.get();
    }
    /** Attempts to fetch an RSS feed using an XMLHttpRequest, and adds its contents to
     * the RSS dummy query list if successful.
     * @function doRssFetch
     * @inner
     * @param {string} feedUrl - the RSS feed's URL
     * */
    function doRssFetch(feedUrl) {
        if (!feedUrl) return;
        cout("Feed Url: " + feedUrl);
        var req = new XMLHttpRequest();
        try {
            req.open('GET', feedUrl, true);
            req.onreadystatechange = function() {
                if (req.readyState === 4) {
                    var doc = req.responseXML;
                    debug(doc);
                    addRssTitles(doc, feedUrl);
                }
            };
            req.send();
        } catch (ex) {
            cout("[WARN]  doRssFetch(" + feedUrl + ")\n" +
                "  " + ex.message + " | Using defaults...");
            return; // no adds here...
        }

    }
    /** Randomly shuffle the words of input queryWords, and add them to incQueries. 
     * Mutates the incQueries array; does not return a value.
     * @function getSubQuery
     * @inner
     * @param {Array} queryWords - words from a dummy query string
     * */
    function getSubQuery(queryWords) {
        var incQuery = "";
        var randomArray = new Array();
        for (var k = 0; k &lt; queryWords.length; k++) {
            let randomIndex = roll(0, queryWords.length - 1);
            if (randomArray.indexOf(randomIndex) &lt; 0)
                randomArray.push(randomIndex);
        }
        randomArray.sort();
        for (k = 0; k &lt; randomArray.length - 1 &amp;&amp; k &lt; 5; k++) {
            incQuery += queryWords[randomArray[k]] + ' ';
        }
        incQuery += queryWords[randomArray[k]];
        if (incQueries)
            incQueries.push(trim(incQuery));
    }
    /** Get a randomQuery() and replace any newline characters with spaces 
     * @function getQuery
     * @inner
     * @returns {string} term - the cleaned query term 
     * */
    function getQuery() {
        var term = randomQuery();
        if (term.indexOf('\n') > 0) { // yuck, replace w' chomp();
            while (true) {
                for (var i = 0; i &lt; term.length; i++) {
                    if (term.charAt(i) === '\n') {
                        term = term.substring(0, i) + ' ' + term.substring(i + 1, term.length);
                        continue;
                    }
                }
                break;
            }
        }
        return term;
    }
    /** Update the TMN badge-icon to Error status.
     * @function updateOnErr 
     * @inner
     * */
    function updateOnErr() {
		try {
			api.browserAction.setBadgeBackgroundColor({'color': [255, 0, 0, 255]});
			api.browserAction.setBadgeText({'text': 'Error'});
			api.browserAction.setTitle({'title': 'TMN Error'});
		} catch (ex){
			debug("browserAction are not supported on mobile")
		}
    }
    /** Update the TMN badge-icon to display the next search.
     * @function updateOnSend
     * @inner
     * @param {string} queryToSend - the next dummy query string
     * */
    function updateOnSend(queryToSend) {
		try{
			api.browserAction.setBadgeBackgroundColor({'color': [113, 113, 198, 255]})
			api.browserAction.setBadgeText({'text': queryToSend});
			api.browserAction.setTitle({'title': engine + ': ' + queryToSend});
		} catch (ex){
			debug("browserAction are not supported on mobile")
		}
    }
    /** Given a set of possible parameters of the current status of TMN, assemble a logEntry and return it.
     * @function createLog
     * @inner
     * @param {string} type - the type of logEntry, from {"URLMap", "error"}
     * @param {string} engine - the current search engine
     * @param {string} [mode] - the current running mode tmn_mode of TMN, unused/deprecated (see calling functions monitorBurst and readDHSList)
     * @param {string} [query] - the current dummy query string, unused/deprecated
     * @param {string} [id] - the current query id, unused/deprecated
     * @param {string} [asearch] - the URL for "a search"
     * @returns {Object} logEntry
     *  */
    function createLog(type, engine, mode, query, id, asearch) {
        var logEntry = {};
        logEntry.type = type;
        logEntry.engine = engine;
        if (mode) logEntry.mode = tmn_mode;
        if (query) logEntry.query = query;
        if (id) logEntry.id = id;
        if (asearch) logEntry.newUrl = asearch;
        return logEntry;
    }
    /** Gets a new dummy query string with getQuery() and sends it, 
     * either implicitly (calling sendQuery with null) or explicitly after splitting >3 word queries. 
     * @function doSearch
     * @inner
     * */
    function doSearch() {
        var newquery = getQuery();
        //try {
            if (incQueries &amp;&amp; incQueries.length > 0)
                sendQuery(null);
            else {
                newquery = getQuery();
                let queryWords = newquery.split(' ');
                if (queryWords.length > 3) {
                    getSubQuery(queryWords);
                    if (useIncrementals) {
                        var unsatisfiedNumber = roll(1, 4);
                        for (var n = 0; n &lt; unsatisfiedNumber - 1; n++)
                            getSubQuery(queryWords);
                    }
                    // not sure what is going on here? -dch
                    if (incQueries &amp;&amp; incQueries.length > 0)
                        newquery = incQueries.pop();
                }
                sendQuery(newquery);
            }
       /* } catch (e) {
            cerr("error in doSearch", e);
        }*/
    }
    /** Sends a search term to the current search engine, either through TMN's tab if enabled, 
     * or through an XMLHttpRequest (with reschedule error handling), and updates the TMN badge icon.
     * @function sendQuery
     * @inner
     * @param {string} queryToSend - the query to send
     * */
    function sendQuery(queryToSend) {
        tmn_scheduledSearch = false;
        var url = getEngineById(engine).urlmap;
        if (queryToSend === null) {
            if (incQueries &amp;&amp; incQueries.length > 0)
                queryToSend = incQueries.pop();
            else {
                if (!queryToSend) cout('sendQuery error! queryToSendis null');
                return;
            }
        }
        if (Math.random() &lt; 0.9) queryToSend = queryToSend.toLowerCase();
        if (queryToSend[0] === ' ') queryToSend = queryToSend.substr(1); //remove the first space ;
        tmn_hasloaded = false;
        if (tmn_options.useTab) {
            var TMNReq = {};
            TMNReq.tmnQuery = queryToSend;
            TMNReq.tmnEngine = JSON.stringify(getEngineById(engine));
            TMNReq.tmnUrlMap = url;
            TMNReq.tmnMode = tmn_mode;
            TMNReq.tmnID = (tmn_options.tmn_id++);
            
            if (getTMNTab() === -1) {
                createTab(TMNReq);
            } else {
                console.log(JSON.stringify(TMNReq));
                api.tabs.sendMessage(tmn_tab_id, TMNReq);
                cout('Message sent to the tab: ' + tmn_tab_id + ' : ' + TMNReq);
            }
        } else {
            var queryURL = queryToURL(url, queryToSend);
            cout("The encoded URL is " + queryURL);
            var xhr = new XMLHttpRequest();
            xhr.open("GET", queryURL, true);
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    clearTimeout(tmn_errTimeout);
                    if (xhr.status >= 200 &amp;&amp; xhr.status &lt; 400) {
                        var logEntry = {};
                        logEntry.type = 'query';
                        logEntry.engine = engine;
                        logEntry.mode = tmn_mode;
                        logEntry.query = queryToSend;
                        logEntry.id = tmn_options.tmn_id++;
                        log(logEntry);
                        tmn_hasloaded = true;
                        reschedule();
                    } else {
                        rescheduleOnError();
                    }
              }
           };
           updateOnSend(queryToSend);
           xhr.send();
           currentTMNURL = queryURL;
      }
    }
    /** Takes a TMN-encoded base-URL for a search engine, "url", and a search query string "query", and combines
     * them to make a sendable search URL  
     * @function queryToURL
     * @inner
     * @param {string} url - the TMN-encoded base-URL for a search engine
     * @param {query} query - the dummy query term generated by TMN
     * */
    function queryToURL(url, query) {
        query = query.toLowerCase();
        var urlQuery = url.replace('|', query);
        urlQuery = urlQuery.replace(/ /g, '+');
        var encodedUrl = encodeURI(urlQuery);
        encodedUrl = encodedUrl.replace(/%253/g, "%3");

        return encodedUrl;
    }
    /** Called after a search error in sendQuery, updates the TMN badge icon UI status, and
     * schedules the next search after a 60s pause (if TMN is enabled)
     * @function rescheduleOnError
     * @inner
     * */
    function rescheduleOnError() {
        var pauseAfterError = Math.max(2 * tmn_options.timeout, 60000);
        tmn_mode = 'recovery';
        burstCount = 0;
        cout("[INFO] Trying again in " + (pauseAfterError / 1000) + "s");
        log({
            'type': 'ERROR',
            'message': 'next search in ' + (pauseAfterError / 1000) + "s",
            'engine': engine
        });
        updateOnErr();

        // reschedule after long pause
        if (tmn_options.enabled)
            scheduleNextSearch(pauseAfterError);
    }
    /** After a search completes, scheduleNextSearch with the appropriate timeout delay,
     * either the burstTimeout if in burst mode or the typical timeout set in tmn_options. 
     * @function reschedule
     * @inner
     * */
    function reschedule() {
        var delay = tmn_options.timeout;

        if (tmn_scheduledSearch) return; 
        tmn_scheduledSearch = true;

        if (isBursting()) { // schedule for burs
            delay = Math.min(delay, burstTimeout);
            scheduleNextSearch(delay);
            tmn_mode = 'burst';
            burstCount--;
        } else { // Not bursting, schedule per usual
            tmn_mode = 'timed';
            scheduleNextSearch(delay);
        }
    }


//Cleaning stop here
    /** If not bursting, modulates the delay with a random offset, chooses a random search engine,
     * and calls the next search after a timeout. If bursting, continue the burst.
     * @function scheduleNextSearch
     * @inner
     * @param {number} delay - the delay in milliseconds to precede the next search
     * */
    function scheduleNextSearch(delay) {
        if (!tmn_options.enabled) return;
        if (delay > 0) {
            if (!isBursting()) { // randomize to approach target frequency
                var offset = delay * (Math.random() / 2);
                delay = parseInt(delay) + offset;
            } else { // just simple randomize during a burst
                delay += delay * (Math.random() - .5);
            }
        }
        prev_engine = engine;
        if (isBursting()) engine = burstEngine;
        else engine = chooseElt(tmn_engines.list.filter(function (x) {return x.enabled})).id;
        debug('NextSearchScheduled on: ' + engine);
        window.clearTimeout(tmn_errTimeout);
        tmn_errTimeout = window.setTimeout(rescheduleOnError, delay * 3);
        window.clearTimeout(tmn_searchTimer);
        tmn_searchTimer = window.setTimeout(doSearch, delay);
    }
    /** Sets the burst engine (the user search engine) and randomly chooses how many
     * searches to burst, between 3 and 10 inclusive.
     * @function enterBurst
     * @inner
     * @param {string} burst_engine - the engine the user searched with, to burst searches on
     * */
    function enterBurst(burst_engine) {
        if (!tmn_options.burstMode) return;
        cout("Entering burst mode for engine: " + burst_engine);
        var logMessage = {
            'type': 'info',
            'message': 'User made a search, start burst',
            'engine': burst_engine
        };
        log(logMessage);
        burstEngine = burst_engine;
        burstCount = roll(3, 10);
    }
    /** Save the current options, engines, and generated queries to local storage.
     * @function saveOptions
     * @inner
     * */
    function saveOptions() {
        cout("Save option: " + JSON.stringify(tmn_options));

        api.storage.local.set({"options_tmn":tmn_options});
        api.storage.local.set({"engines_tmn":tmn_engines});
        api.storage.local.set({"gen_queries":TMNQueries});
    }
    /** Disables TMN in tmn_options, deletes the TMN tab, updates the TMN badge icon UI, and clears the search timers.
     * @function stopTMN
     * @inner
     * */
    function stopTMN() {
        tmn_options.enabled= false;
        deleteTab();
		try {
			api.browserAction.setBadgeBackgroundColor({'color': [255, 0, 0, 255]});
			api.browserAction.setBadgeText({'text': 'Off'});
			api.browserAction.setTitle({'title': 'Off'});
		} catch (ex) {
			debug("browserAction are not supported on mobile")
		}
        window.clearTimeout(tmn_searchTimer);
        window.clearTimeout(tmn_errTimeout);
    }
    /** Formats single digit time values into two-digit time strings.
     * @function formatNum
     * @inner
     * @param {number} val - a time number
     * */
    function formatNum(val) {
        if (val &lt; 10) return '0' + val;
        return val;
    }
    /** Given an input log entry, if logs are enabled, get the current time &amp; date and add them to the entry,
     * then add the entry to the logs and save the logs to local storage.
     * @function add_log
     * @inner
     * @param {object} entry - the log entry to add
     * */
    function log(entry) {
        if (tmn_options.disableLogs) return;
        try {
            if (entry !== null) {
                if (entry.type === 'query') {
                    if (entry.id &amp;&amp; entry.id === tmn_logged_id) return;
                    tmn_logged_id = entry.id;
                }
                var now = new Date();
                entry.date = formatNum(now.getHours()) + ":" + formatNum(now.getMinutes()) + ":" + formatNum(now.getSeconds()) +
                             '   ' + (now.getMonth() + 1) + '/' + now.getDate() + '/' + now.getFullYear();
            }
        } catch (ex) {
            cout("[ERROR] " + ex + " / " + ex.message + "\nlogging msg");
        }
        tmnLogs.unshift(entry);
        api.storage.local.set({"logs_tmn":tmnLogs});
    }
    /** Tries to send a click event to the last search engine in the TMN tab.
     * @function sendClickEvent
     * @inner
     * */
    function sendClickEvent() {
        if (!prev_engine) return;
        cout("Will send click event on: " + prev_engine);
        try {
            api.tabs.sendMessage(tmn_tab_id, {
                click_eng: getEngineById(prev_engine)
            });
        } catch (ex) {
            cout(ex);
        }
    }
    /** Schedules the first search with a 4s delay, adds a webNavigation listener for burst mode,
     * and adds a listener to remove all logs when the window closes, if saving logs is disabled.
     * @function startTMN
     * @inner
     * */
     function startTMN() {
            scheduleNextSearch(4000);
            monitorBurst();
            api.windows.onRemoved.addListener(function() {
                if (!tmn_options.saveLogs)
                    api.storage.local.set({"logs_tmn":""});
            });

    }
    /** Parses requests from the extension and serves the response.
     * Requests include: ["tmnLog", "updateStatus", "getURLMap", "setURLMap", "tmn" (a subset of requests)]
     * "tmn" => ["currentURL", "pageLoaded", "tmnError", "isActiveTab", "TMNValideFeeds" - calls validateFeeds on the request.param]
     * @function handleRequest
     * @inner
     * @param {object} request
     * @param {object} sender
     * @param {object} sendResponse
     * */
    function handleRequest(request, sender, sendResponse) {
        if (request.tmnLog) {
            cout("Background logging : " + request.tmnLog);
            var logtext = JSON.parse(request.tmnLog);
            log(logtext);
            sendResponse({});
            return;
        }
        if (request.updateStatus) {
            updateOnSend(request.updateStatus);
            sendResponse({});
            return;
        }
        if (request.getURLMap) {
            var engine = request.getURLMap;
            var urlMap = currentUrlMap[engine];
            sendResponse({"url": urlMap});
            return;
        }
        if (request.setURLMap) {
            cout("Background handling : " + request.setURLMap);
            var vars = request.setURLMap.split('--');
            var eng = vars[0];
            var asearch = vars[1];
            currentUrlMap[eng] = asearch;
            api.storage.local.set({"url_map_tmn":currentUrlMap});
            var logEntry = {};
            logEntry.type = 'URLmap';
            logEntry.engine = eng;
            logEntry.newUrl = asearch;
            TRACKMENOT.TMNSearch.log(logEntry);
            sendResponse({});
            return;
        }

        switch (request.tmn) {
            case "currentURL":
                sendResponse({
                    "url": currentTMNURL
                });
                return;
            case "pageLoaded": 
                if (!tmn_hasloaded) {
                    tmn_hasloaded = true;
                    clearTimeout(tmn_errTimeout);
                    reschedule();
                    if (Math.random() &lt; 1) {
                        var time = roll(10, 1000);
                        window.setTimeout(sendClickEvent, time);
                    }
                    sendResponse({});
                }
                break;
            case "tmnError": //Remove timer and then reschedule;
                clearTimeout(tmn_errTimeout);
                rescheduleOnError();
                sendResponse({});
                break;
            case "isActiveTab":
                var active = (!sender.tab || sender.tab.id === tmn_tab_id);
                cout("active: " + active);
                sendResponse({
                    "isActive": active
                });
                return;
            case "TMNValideFeeds":
                validateFeeds(request.param);
                break;
            default:
                sendResponse({}); 
            sendResponse({});
            return;
        }

    }
    /** Sets the default options for TMN in the tmn_options object, 
     * including the timeout, blacklist, and feedlist.
     * Also sets (among other variables) the tmn_id, the id for the current search.
     * @function setDefaultOptions
     * @inner
     * */
    function setDefaultOptions() {
        tmn_options.enabled= true;
        tmn_options.timeout = 6000;
        tmn_options.burstMode = true;
        tmn_options.useTab= false;
        tmn_options.use_black_list = true;
        tmn_options.use_dhs_list = false;
        tmn_options.kwBlackList = ['bomb', 'porn', 'pornographie'];
        tmn_options.saveLogs= true;
        tmn_options.feedList = ['http://www.techmeme.com/index.xml','http://rss.slashdot.org/Slashdot/slashdot','http://feeds.nytimes.com/nyt/rss/HomePage'];
        tmn_options.disableLogs= false;
        tmn_options.tmn_id = 0;     
    }
    /** Initializes the query lists - zeitgeist queries come from a pre-set static list of queries,
     * and RSS queries are loaded from RSS feeds. If DHS queries are enabled, these are loaded.
     * @function initQueries
     * @inner
     * */
    function initQueries() {
        typeoffeeds =['zeitgeist','rss'];
        
        TMNQueries = {};
        TMNQueries.zeitgeist = zeit_queries;
        
        
        TMNQueries.rss = [];
        let feeds = tmn_options.feedList;
        feeds.forEach(doRssFetch); 
        
        
        if (tmn_options.use_dhs_list ) {
            readDHSList();
            typeoffeeds.push('dhs');
         } else {
            typeoffeeds.splice(typeoffeeds.indexOf('dhs'), 1);
            TMNQueries.dhs = null;
        }
    }
    /** Callback function for getStorage that logs an error to the console.
     * @function onError
     * @inner
     * @param error
     * */
    function onError(error) {
      console.log(`Error: ${error}`);
    }
    /** wrapper function to access local storage, using storage item key and a callback function to pass the got item(s) 
     * @param {Array} keys - the identifiers for stored properties of TrackMeNot (e.g. ["options_tmn", "gen_queries", "engines_tmn", "logs_tmn"])
     * @param {Function} callback - the callback function to feed the stored items to (e.g. TRACKMENOT.TMNSearch._restoreTMN)
     * @function getStorage
     * @inner
     * */
	function getStorage(keys,callback) {
		try {
			let gettingItem = api.storage.local.get(keys);
			gettingItem.then(callback, onError);
		} catch (ex) {
			chrome.storage.local.get(keys,callback); 
		}   
	}
    /** Sets the tmn_engines variable to the default_engines constant.
     * @function setDefaultEngines
     * @inner
     * */
    function setDefaultEngines() {
        tmn_engines = default_engines;
    }
    /** Restores tmn_options to values from local storage, initializes the query lists (if using RSS feeds),
     * refreshes the TMN tab status, and updates the TMN badge icon UI.
     * @function restoreOptions
     * @inner
     * @param item - the saved local storage options
     * */
    function restoreOptions (item) {
        tmn_options = item;
        debug("Restore: " + tmn_options.enabled);
        
        if (tmn_options.feedList) {
            initQueries();  
        }

        changeTabStatus(tmn_options.useTab);     
		try{
			if (tmn_options.enabled) {
				api.browserAction.setBadgeText({'text': 'ON'});
				api.browserAction.setTitle({'title': 'TMN is ON'});
			} else {
				api.browserAction.setBadgeText({'text': 'OFF'});
				api.browserAction.setTitle({'title': 'TMN is OFF'});
			}
		} catch (ex) {
			debug("browserAction are not supported on mobile")
		}
        
    }
    /** Applies new options to the search behavior (e.g., generating a new set of queries given a changed
     * list of RSS feeds).
     * @function updateOptions
     * @inner
     * @param item - the new TMN options
     * */
    function updateOptions (item) {
        tmn_options = item;
        debug("Restore: " + tmn_options.enabled);
        
        if ( tmn_options.feedList !== item.feedList  ){
            tmn_options.feedList = item.feedList ;
            if (tmn_options.feedList) {
                initQueries();  
            }
        }

        if ( tmn_options.enabled !== item.enabled  ){
            tmn_options.enabled = item.enabled;
            if (tmn_options.enabled)  startTMN();
            else stopTMN();
        }

        changeTabStatus(tmn_options.useTab); 
		try {
			if (tmn_options.enabled) {
				api.browserAction.setBadgeText({'text': 'ON'});
				api.browserAction.setTitle({'title': 'TMN is ON'});
			} else {
				api.browserAction.setBadgeText({'text': 'OFF'});
				api.browserAction.setTitle({'title': 'TMN is OFF'});
			}
		} catch (ex) {
			debug("browserAction are not supported on mobile")
		}
    }
    
    /** sets search engines to new set of values if new set of values present, 
     * otherwise restores to default and overwrites local storage engine settings 
     * @function setEngines
     * @inner
     * */
    function setEngines(item) {
        if(item) {
            tmn_engines = item;
        } else {
            tmn_engines = default_engines;
            api.storage.local.set({"engines_tmn":tmn_engines});
        }
    }
	/** Sets the query lists to restored query list values from local storage.
     * @function restoreQueries
     * @inner
     * @param item
     * */
	function restoreQueries(item) {
		if (item) {
			TMNQueries = item;
		}
	}


    return {

        _handleRequest: function(request, sender, sendResponse) {
            handleRequest(request, sender, sendResponse);
        },
        /** called on api.storage.onChanged event listener, updates options and engines with new values 
         * @function _logStorageChange
         * @inner
         * @param {array} items - new values of stored TMN objects
         * */
        _logStorageChange: function (items) {
            if ('options_tmn' in items) 
                updateOptions(items.options_tmn.newValue);
            if ('engines' in items)
                setEngines(items.engines.newValue);        
        },
        /** callback function called on extension startup with contents of local storage for engines, options, logs, and gen_queries 
         * @function _restoreTMN
         * @inner
         * @param {array} items - items from local storage
         * */
        _restoreTMN: function (items) {
            if (!items["engines_tmn"]) {			
               setDefaultEngines(); 
            } else {       
			   restoreQueries(items["gen_queries"]);
               setEngines(items["engines_tmn"]); 
            }
            
            if (!items["options_tmn"]) {
                setDefaultOptions();
                cout("Init: " + tmn_options.enabled);
            } else {
                restoreOptions(items["options_tmn"]);
            }
            initQueries();

                 
            try {
                tmnLogs = items(["logs_tmn"]);
            } catch (ex) {
                tmnLogs = [];
                cout("can not restore logs")
            }
            saveOptions();
            startTMN();
        },
        /** 
         * @function _getEngine
         * @inner
         * @returns {string} engine - the current search engine
         * */
        _getEngine: function() {
            return engine;
        },
        /** 
         * @function _getQueries
         * @inner
         * @returns {object} TMNQueries - the dummy query strings for TMN to search with, organized by keys representing the method of query generation {@link typeoffeeds} ("rss", "extracted", "dhs")
         * */
        _getQueries: function() {
   
            return TMNQueries; 
        },
        /** Wrapper function to retrieve a set of values from local storage and feed them to a given callback function.
         * @function _getStorage
         * @inner
         * @param {array} keys - an array of keys (names of variables) to retrieve from local storage
         * @param {function} callback
         * */
         _getStorage: function(keys,callback) {
            getStorage(keys,callback);
         },
         /** Sets all engines and options to their default values, and re-initializes the query lists,
         * then saves the default values to local storage.
         * @function _resetSettings
         * @inner
         * */
        _resetSettings: function () {			
            setDefaultEngines(); 
            setDefaultOptions();
            initQueries();
        
            try {
                tmnLogs = items(["logs_tmn"]);
            } catch (ex) {
                tmnLogs = [];
                cout("can not restore logs")
            }
            saveOptions();

        },
        /** Checks if a given deleted tab's ID matches the TMN tab id, and if so, 
         * marks the TMN tab as deleted by setting tmn_tab_id to -1.
         * @function _preserveTMNTab
         * @inner
         * @param {number} tab_id - the deleted tab's ID
         * */
		 _preserveTMNTab: function(tab_id) {
            if (tmn_tab_id===tab_id) {
                tmn_tab_id = -1;
                cout('TMN tab has been deleted by the user, reload it');
                return;
            }
        }

    }

}();



api.runtime.onMessage.addListener(TRACKMENOT.TMNSearch._handleRequest);

api.tabs.onRemoved.addListener(TRACKMENOT.TMNSearch._preserveTMNTab);

TRACKMENOT.TMNSearch._getStorage(["options_tmn","gen_queries","engines_tmn","logs_tmn"],TRACKMENOT.TMNSearch._restoreTMN);
api.storage.onChanged.addListener(TRACKMENOT.TMNSearch._logStorageChange);</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a> on Mon Jan 29 2024 23:53:47 GMT-0500 (Eastern Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



    <script src="./../.link-fixer.js"></script>
    
</body>
</html>
